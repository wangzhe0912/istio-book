{"./":{"url":"./","title":"Welcome","keywords":"","body":"istio-book Istio中文入门手册 欢迎来到本书。 本书主要基于 Istio 1.8.3 版本进行使用说明。 以 Istio 的官方文档为基础，并补充了自己在实践过程中遇到的一些问题和思考。 希望可以帮助大家更快更好的对 Istio 有一个基本的了解，并且能够运用到业务中。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap01/what_is_istio.html":{"url":"chap01/what_is_istio.html","title":"Istio是什么","keywords":"","body":"Istio 是什么 目前，云平台已经令使用了它们的公司受益匪浅。 但不可否认的是，上云会给 DevOps 团队带来压力。 为了可移植性，开发人员必须使用微服务来构建应用，同时运维人员也正在管理着极端庞大的混合云和多云的部署环境。 而 Istio 正是为了帮助你来进行连接、保护、控制和观察服务。 从较高的层面来说，Istio 有助于降低这些部署的复杂性，并减轻开发团队的压力。 它是一个完全开源的服务网格，作为透明的一层接入到现有的分布式应用程序里。 它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。 Istio 多样化的特性使您能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。 服务网格是什么 Istio 解决了开发人员和运维人员所面临的从单体应用向分布式微服务架构转变的挑战。 了解它是如何做到这一点的可以让我们更详细地理解 Istio 的服务网格。 服务网格用来描述组成这些应用程序的微服务网络以及它们之间的交互。 随着服务网格的规模和复杂性不断的增长，它将会变得越来越难以理解和管理。 它的需求包括服务发现、负载均衡、故障恢复、度量和监控等。 服务网格通常还有更复杂的运维需求，比如 A/B 测试、金丝雀发布、速率限制、访问控制和端到端认证。 Istio 提供了对整个服务网格的行为洞察和操作控制的能力，以及一个完整的满足微服务应用各种需求的解决方案。 为什么要使用 Istio？ 通过负载均衡、服务间的身份验证、监控等方法，Istio 可以轻松地创建一个已经部署了服务的网络，而服务的代码只需很少更改甚至无需更改。 通过在整个环境中部署一个特殊的 sidecar 代理为服务添加 Istio 的支持，而代理会拦截微服务之间的所有网络通信，然后Istio使用其控制平面的功能来配置和管理这些代理服务，这包括： 为 HTTP、gRPC、WebSocket 和 TCP 流量自动负载均衡。 通过丰富的路由规则、重试、故障转移和故障注入对流量行为进行细粒度控制。 可插拔的策略层和配置 API，支持访问控制、速率限制和配额。 集群内（包括集群的入口和出口）所有流量的自动化度量、日志记录和追踪。 在具有强大的基于身份验证和授权的集群中实现安全的服务间通信。 Istio 为可扩展性而设计，可以满足不同的部署需求。 它是通过流量的拦截和规则的配置来实现流量控制的，整体架构图如下所示: 核心特性 Istio 以统一的方式提供了许多多服务网络访问的关键功能： 流量管理 Istio 简单的规则配置和流量路由允许您控制服务之间的流量和 API 调用过程。 Istio 简化了服务级属性（如熔断器、超时和重试）的配置，并且让它轻而易举的实现重要功能（如 A/B 测试、金丝雀发布和按流量百分比划分的分阶段发布）。 有了更好的对流量的可观测性和开箱即用的故障恢复特性，您就可以在问题产生之前捕获它们，无论面对什么情况都可以使调用更可靠，网络更健壮。 安全 Istio 的安全功能使开发人员能够专注于应用程序级别的安全性。 Istio 提供底层安全通信通道，并大规模管理服务通信的身份验证、授权和加密。 使用 Istio，服务通信在默认情况下是安全的，让您可以跨不同的协议和运行时一致地实施策略，而所有这些都几乎不需要更改应用程序。 虽然 Istio 是独立于平台的，但是将它与 Kubernetes（或基础设施）网络策略一起使用，确可以获得更大的收益， 例如能够在网络和应用程序层保护 pod 到 pod 或服务到服务的通信。 可观察性 Istio 强大的追踪、监控和日志特性让您能够深入的了解服务网格部署。 通过 Istio 的监控能力，可以真正的了解到服务的性能是如何影响上游和下游的；而它的定制 Dashboard 提供了对所有服务性能的可视化能力，并让您看到它如何影响其他进程。 Istio 的 Mixer 组件负责策略控制和遥测数据收集。 它提供了后端抽象和中介，将一部分 Istio 与后端的基础设施实现细节隔离开来，并为运维人员提供了对网格与后端基础实施之间交互的细粒度控制。 所有这些特性都使您能够更有效地设置、监控和加强服务的 SLO。当然，至少是也可以帮助您快速有效地检测到并修复出现的问题。 平台支持 Istio 在设计上是独立于具体平台的，例如可以在各种环境中运行，包括跨云、内部环境、Kubernetes、Mesos 等等。 您可以在 Kubernetes 或是装有 Consul 的 Nomad 环境上部署 Istio。 Istio 目前支持： Kubernetes 上的服务部署。 基于 Consul 的服务注册。 服务运行在独立的虚拟机/物理机上。 整合和定制 Istio 的策略实施组件可以扩展和定制，与现有的 ACL、日志、监控、配额、审查等解决方案集成。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap01/traffic_management.html":{"url":"chap01/traffic_management.html","title":"流量管理","keywords":"","body":"Istio 流量管理 Istio 的流量路由规则可以让我们很容易的控制服务之间的流量和 API 调用。 Istio 简化了服务级别属性的配置，比如熔断器、超时和重试，并且能轻松的设置重要的任务，如 A/B 测试、金丝雀发布、基于流量百分比切分的概率发布等。 它还提供了开箱即用的故障恢复特性，有助于增强应用的健壮性，从而更好地应对被依赖的服务或网络发生故障的情况。 Istio 的流量管理模型源于和服务一起部署的 Envoy 代理。 网格内服务发送和接收的所有流量（data plane流量）都经由 Envoy 代理，这让控制网格内的流量变得异常简单，而且不需要对服务做任何的更改。 本节中描述的功能特性，如果我们对它们是如何工作的感兴趣的话，可以在 架构概述 中找到关于 Istio 的流量管理实现的更多信息。 本部分只介绍 Istio 的流量管理特性。 概述 为了在服务网格中导流，Istio 需要知道所有的 endpoint 在哪和它属于哪个服务。 为了定位到service registry(服务注册中心)，Istio 会连接到一个服务发现系统。 例如，如果我们在 Kubernetes 集群上安装了 Istio，那么它将自动检测该集群中的服务和 endpoint。 使用此服务注册中心，Envoy 代理可以将流量定向到相关服务。 大多数基于微服务的应用程序，每个服务的工作负载都有多个实例来处理流量，称为负载均衡池。 默认情况下，Envoy 代理基于轮询调度模型在服务的负载均衡池内分发流量，按顺序将请求发送给池中每个成员，一旦所有服务实例均接收过一次请求后，重新回到第一个池成员。 Istio 基本的服务发现和负载均衡能力为我们提供了一个可用的服务网格，但它能做到的远比这多的多。 在许多情况下，我们可能希望对网格的流量情况进行更细粒度的控制。 作为 A/B 测试的一部分，我们可能想将特定百分比的流量定向到新版本的服务，或者为特定的服务实例子集应用不同的负载均衡策略。 我们可能还想对进出网格的流量应用特殊的规则，或者将网格的外部依赖项添加到服务注册中心。 通过使用 Istio 的流量管理 API 将流量配置添加到 Istio，就可以完成所有这些甚至更多的工作。 和其他 Istio 配置一样，这些 API 也使用 Kubernetes 的自定义资源定义（CRDs）来声明，我们可以像示例中看到的那样使用 YAML 进行配置。 接下来，我们将会对 Istio 流量管理中用到的这些 API 资源对象依次进行讲解和说明。 VirtualService VirtualService 和 DestinationRule 是 Istio 流量路由功能中最核心的对象。 VirtualService 让我们配置如何在服务网格内将请求路由到服务，这基于 Istio 和平台提供的基本的连通性和服务发现能力。 每个 VirtualService 包含一组路由规则，Istio 按顺序去评估它们，Istio 将每个给定的请求匹配到VirtualService指定的实际目标地址。 为什么需要 VirtualService VirtualService 在增强 Istio 流量管理的灵活性和有效性方面，发挥着至关重要的作用。 通过对客户端请求的目标地址与真实响应请求的目标工作负载进行解耦来实现。 VirtualService同时提供了丰富的方式，为发送至这些工作负载的流量指定不同的路由规则。 为什么 VirtualService 如此有用？ 就像在之前的介绍中所说，如果没有VirtualService，Envoy 会在所有的服务实例中使用轮询的负载均衡策略分发请求。 我们可以用我们对工作负载的了解来改善这种行为。 例如，有些可能代表不同的版本。这在 A/B 测试中可能有用，我们可能希望在其中配置基于不同服务版本的流量百分比路由，或指引从内部用户到特定实例集的流量。 使用VirtualService，我们可以为一个或多个主机名指定流量行为。 在VirtualService中使用路由规则，告诉 Envoy 如何发送VirtualService的流量到适当的目标。 路由目标地址可以是同一服务的不同版本，也可以是完全不同的服务。 一个典型的场景是将流量发送到被指定为服务子集的服务的不同版本。 客户端将 VirtualService 视为一个统一入口，将请求发送至 VirtualService 主机，然后 Envoy 根据 VirtualService 规则把流量路由到不同的版本。 例如，“20% 的调用转到新版本”或“将这些用户的调用转到版本 2”。 这其实是一个典型的金丝雀发布，我们可以逐步增加发送到新版本服务的流量百分比。 流量路由完全独立于实例部署，这意味着实现新版本服务的实例可以根据流量的负载来伸缩，完全不影响流量路由。 此外，VirtualService还可以帮助我们： 通过单个VirtualService处理多个应用程序服务，我们可以配置一个VirtualService处理特定命名空间中的所有服务。映射单一的VirtualService到多个“真实”服务特别有用，可以在不需要客户适应转换的情况下，将单体应用转换为微服务构建的复合应用系统。我们的路由规则可以指定为“对这些 monolith.com 的 URI 调用转到microservice A”等等。。 和网关整合并配置流量规则来控制出入流量。 在某些情况下，我们还需要配置DestinationRule来使用这些特性，因为这是指定服务子集的地方。 在一个单独的对象中指定服务子集和其它特定目标策略，有利于在VirtualService之间更简洁地重用这些规则。在后续的内容中，我们可以找到更多关于DestinationRule的内容。 VirtualService 示例 下面，我们来看一个 VirtualService 的示例，它的功能是根据请求是否来自特定的用户，把它们路由到服务的不同版本: apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews spec: hosts: - reviews http: - match: - headers: end-user: exact: jason route: - destination: host: reviews subset: v2 - route: - destination: host: reviews subset: v3 下面，我们对一些核心点进行分析， 首先来看一下 hosts 字段： hosts 字段用于列举VirtualService的主机: 即用户指定的目标或是路由规则设定的目标。这是客户端向服务发送请求时使用的一个或多个地址。 hosts: - reviews VirtualService主机名可以是 IP 地址、DNS 名称，或者依赖于平台的一个简称（例如 Kubernetes 服务的短名称），隐式或显式地指向一个完全限定域名（FQDN）。 也可以使用通配符（“*”）前缀，让我们创建一组匹配所有服务的路由规则。 VirtualService的 hosts 字段实际上不必是 Istio 服务注册的一部分，它只是虚拟的目标地址。这让我们可以为没有路由到网格内部的虚拟主机建模。 接下来，我们来了解一下 路由规则: 在 http 字段包含了VirtualService的路由规则，这些路由规则用来描述匹配条件和路由行为，它们把原本发送到 hosts 字段的 HTTP/1.1、HTTP2 和 gRPC 等流量发送到规则中指定的目标上。 （我们也可以用 tcp 和 tls 片段为 TCP 和未终止的 TLS 流量设置路由规则）。 下面，我们来看一下匹配规则是如何定义的。 示例中的第一个路由规则有一个条件，因此以 match 字段开始。 在本例中，我们希望此路由应用于来自 ”jason“ 用户的所有请求，所以使用 headers、end-user 和 exact 字段选择适当的请求。 - match: - headers: end-user: exact: jason route 部分的 destination 字段指定了符合此条件的流量的实际目标地址。 与VirtualService的 hosts 不同，destination 的 host 必须是存在于 Istio 服务注册中心的实际目标地址，否则 Envoy 不知道该将请求发送到哪里。 它可以是一个有代理的服务网格，或者是一个通过服务入口被添加进来的非网格服务。 本示例运行在 Kubernetes 环境中，host 名为一个 Kubernetes 服务名： route: - destination: host: reviews subset: v2 请注意，在该示例和本页其它示例中，为了简单，我们使用 Kubernetes 的短名称设置 destination 的 host。 在评估此规则时，Istio 会添加一个基于VirtualService命名空间的域后缀，这个VirtualService包含要获取主机的完全限定名的路由规则。 在我们的示例中使用短名称也意味着我们可以复制并在任何喜欢的命名空间中尝试它们。 Ps: 只有在目标主机和VirtualService位于相同的 Kubernetes 命名空间时才可以使用这样的短名称。 因为使用 Kubernetes 的短名称容易导致配置出错，我们建议我们在生产环境中指定完全限定的主机名。 destination 部分还指定了 Kubernetes 服务的子集，将符合此规则条件的请求转入其中。 在本例中子集名称是 v2。 我们可以在后续的目标规则中看到如何定义服务子集。 从上面的示例中，我们其实可以看到，在 http 字段下，我们可以包含多个路由规则，那么具体应该哪一个路由规则生效呢？它们的优先级是什么样的呢？ 路由规则按从上到下的顺序选择，虚拟服务中定义的第一条规则有最高优先级。 本示例中，所有不满足第一个路由规则的流量均会流向default目标，default 目标本质上就是一个没有 match 条件的规则。 - route: - destination: host: reviews subset: v3 如上述示例所示，我们建议提供一个默认的“无条件”或基于权重的规则作为每一个虚拟服务的最后一条规则，从而确保流经虚拟服务的流量至少能够匹配一条路由规则。 除了根据 Header 字段来进行流量调度外，我们还可以在流量端口、URI等内容上设置匹配条件，例如： apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: bookinfo spec: hosts: - bookinfo.com http: - match: - uri: prefix: /reviews route: - destination: host: reviews - match: - uri: prefix: /ratings route: - destination: host: ratings 如上示例中，这个虚拟服务让用户发送请求到两个独立的服务：ratings 和 reviews，就好像它们是 http://bookinfo.com/ 这个更大的虚拟服务的一部分。 虚拟服务规则根据请求的 URI 匹配流量来指向适当服务的请求。 在一些match表达式中，除了精准匹配之外，还可以使用前缀匹配或正则匹配等多种匹配方式。 我们可以使用 AND 向同一个 match 块添加多个匹配条件，或者使用 OR 向同一个规则添加多个 match 块。 对于任何一个虚拟服务也可以有多个路由规则。这些组合可以帮助你在单个虚拟服务中使路由条件变得非常灵活和强大。 另外，我们还可以使用匹配条件我们可以按百分比”权重“分发请求。这在 A/B 测试和金丝雀发布中非常有用： spec: hosts: - reviews http: - route: - destination: host: reviews subset: v1 weight: 75 - destination: host: reviews subset: v2 weight: 25 我们也可以使用路由规则在流量上执行一些操作，例如： 添加或删除 header。 重写 URL。 为调用这一目标地址的请求设置重试策略。 想要进一步了解如果使用这些功能，可以参考 HTTPRoute 。 DestinationRule 与虚拟服务一样，目标规则也是 Istio 流量路由功能的关键部分。 我们可以将虚拟服务视为将流量如何路由到给定目标地址，然后使用目标规则来配置该目标的流量。 在评估虚拟服务路由规则之后，目标规则将应用于流量的“真实”目标地址。 特别是，我们可以使用目标规则来指定命名的服务子集，例如按版本为所有给定服务的实例分组。 然后可以在虚拟服务的路由规则中使用这些服务子集来控制到服务不同实例的流量。 目标规则还允许我们在调用整个目的地服务或特定服务子集时定制 Envoy 的流量策略，比如我们喜欢的负载均衡模型、TLS 安全模式或熔断器设置。 默认情况下，Istio 使用轮询的负载均衡策略，实例池中的每个实例依次获取请求。 负载均衡策略 Istio 同时支持如下的负载均衡模型，可以在 DestinationRule 中为流向某个特定服务或服务子集的流量指定这些负载均衡模型： 随机: 请求以随机的方式转到池中的实例。 权重: 请求根据指定的百分比转到实例。 最少请求: 请求被转到最少被访问的实例。 DestinationRule 示例 在下面的示例中，目标规则为 my-svc 目标服务配置了 3 个具有不同负载均衡策略的子集： apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: my-destination-rule spec: host: my-svc trafficPolicy: loadBalancer: simple: RANDOM subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2 trafficPolicy: loadBalancer: simple: ROUND_ROBIN - name: v3 labels: version: v3 其中，每个子集都是基于一个或多个 labels 定义的，在 Kubernetes 中它是附加到像 Pod 这种对象上的键/值对。 这些标签应用于 Kubernetes 服务的 Deployment 并作为 metadata 来识别不同的版本。 除了定义子集之外，目标规则对于所有子集都有默认的流量策略，而对于有定义的子集，则有特定于子集的策略覆盖它。 例如，定义在 subsets 上的默认策略，为 v1 和 v3 子集设置了一个简单的随机负载均衡器。在 v2 策略中，轮询负载均衡器被指定在相应的子集字段上。 网关 使用网关可以为网格来管理入站和出站流量，从而可以管理进入或离开网格的流量。 网关配置被用于运行在网格边界的独立 Envoy 代理，而不是服务工作负载的 sidecar 代理。 与 Kubernetes Ingress API 这种控制进入系统流量的机制不同，Istio 网关让我们充分利用流量路由的强大能力和灵活性。 其中，主要的原因是Istio的网关资源不仅仅生效于应用层流量（L7），同时还可以配置4-6层的负载均衡属性。 网关主要用于管理进入的流量，但我们也可以配置出口网关。 出口网关让您为离开网格的流量配置一个专用的出口节点，这可以限制哪些服务可以或应该访问外部网络，或者启用出口流量安全控制为您的网格添加安全性。 当然，您也可以使用网关配置一个纯粹的内部代理。 Istio 提供了一些预先配置好的网关代理部署（istio-ingressgateway 和 istio-egressgateway）供您使用，在demo的安装中，它们都已经部署好了。 网关示例 下面的示例展示了一个外部 HTTPS 入口流量的网关配置： apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: ext-host-gwy spec: selector: app: my-gateway-controller servers: - port: number: 443 name: https protocol: HTTPS hosts: - ext-host.example.com tls: mode: SIMPLE serverCertificate: /tmp/tls.crt privateKey: /tmp/tls.key 这个网关配置让 HTTPS 流量从 ext-host.example.com 通过 443 端口流入网格，但没有为请求指定任何路由规则。 为想要工作的网关指定路由，您必须把网关绑定到虚拟服务上。 正如下面的示例所示，使用虚拟服务的 gateways 字段进行设置： apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: virtual-svc spec: hosts: - ext-host.example.com gateways: - ext-host-gwy 然后就可以为出口流量配置带有路由规则的虚拟服务。 Service Entries 使用服务入口可以向Istio 内部维护的服务注册中心添加一个请求入口。 添加了服务入口后，Envoy 代理可以向服务发送流量，就好像它是网格内部的服务一样。 配置服务入口允许您管理运行在网格外的服务的流量，它包括以下几种能力： 为外部目标 redirect 和转发请求，例如来自 web 端的 API 调用，或者流向遗留老系统的服务。 为外部目标定义重试、超时和故障注入策略。 添加一个运行在虚拟机的服务来扩展您的网格。 从逻辑上添加来自不同集群的服务到网格，在 Kubernetes 上实现一个多集群 Istio 网格。 您不需要为网格服务要使用的每个外部服务都添加服务入口。 默认情况下，Istio 配置 Envoy 代理将请求传递给未知服务。 但是，您不能使用 Istio 的特性来控制没有在网格中注册的目标流量。 服务入口示例 下面示例的 mesh-external 服务入口将 ext-resource 外部依赖项添加到 Istio 的服务注册中心： apiVersion: networking.istio.io/v1alpha3 kind: ServiceEntry metadata: name: svc-entry spec: hosts: - ext-svc.example.com ports: - number: 443 name: https protocol: HTTPS location: MESH_EXTERNAL resolution: DNS 您可以使用 hosts 字段指定外部资源，可以使用完全限定名或通配符作为前缀域名。 您可以配置虚拟服务和目标规则，以更细粒度的方式控制到服务入口的流量，这与网格中的任何其他服务配置流量的方式相同。 例如，下面的目标规则配置流量路由以使用双向 TLS 来保护到 ext-svc.example.com 外部服务的连接，我们使用服务入口配置了该外部服务： apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: ext-res-dr spec: host: ext-svc.example.com trafficPolicy: tls: mode: MUTUAL clientCertificate: /etc/certs/myclientcert.pem privateKey: /etc/certs/client_private_key.pem caCertificates: /etc/certs/rootcacerts.pem SideCar 默认情况下，Istio 让每个 Envoy 代理都可以访问来自和它关联的工作负载的所有端口的请求，然后转发到对应的工作负载。 您可以使用 sidecar 配置去做下面的事情： 微调 Envoy 代理接受的端口和协议集。 限制 Envoy 代理可以访问的服务集合。 您可能希望在较庞大的应用程序中限制这样的 sidecar 可达性，配置每个代理能访问网格中的任意服务可能会因为高内存使用量而影响网格的性能。 您可以指定将 sidecar 配置应用于特定命名空间中的所有工作负载，或者使用 workloadSelector 选择特定的工作负载。 例如，下面的 sidecar 配置将 bookinfo 命名空间中的所有服务配置为仅能访问运行在相同命名空间和 Istio 控制平面中的服务（目前需要使用 Istio 的策略和遥测功能）： apiVersion: networking.istio.io/v1alpha3 kind: Sidecar metadata: name: default namespace: bookinfo spec: egress: - hosts: - \"./*\" - \"istio-system/*\" 网络弹性与测试 除了为您的网格导流之外，Istio 还提供了可选的故障恢复和故障注入功能，您可以在运行时动态配置这些功能。 使用这些特性可以让您的应用程序运行稳定，确保服务网格能够容忍故障节点，并防止局部故障级联影响到其他节点。 超时 超时是 Envoy 代理等待来自给定服务的答复的时间量，以确保服务不会因为等待答复而无限期的挂起，并在可预测的时间范围内返回调用成功或失败。 HTTP 请求的默认超时时间是 15 秒，这意味着如果服务在 15 秒内没有响应，调用将失败。 对于某些应用程序和服务，Istio 的缺省超时可能不合适。 例如，超时太长可能会由于等待失败服务的回复而导致过度的延迟；而超时过短则可能在等待涉及多个服务返回的操作时触发不必要地失败。 为了找到并使用最佳超时设置，Istio 允许您使用虚拟服务按服务轻松地动态调整超时，而不必修改您的业务代码。 下面的示例是一个虚拟服务，它对 ratings 服务的 v1 子集的调用指定 10 秒超时： apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: ratings spec: hosts: - ratings http: - route: - destination: host: ratings subset: v1 timeout: 10s 重试 重试设置指定如果首次调用失败，Envoy 代理尝试连接服务的最大次数。 重试通过确保请求不会因为偶发的抖动而失败，从而可以提高服务可用性和应用程序的性能。 重试之间的间隔（25ms+）是可变的，并由 Istio 自动确定，从而防止被调用服务被请求淹没。 HTTP 请求的默认重试行为是在返回错误之前重试两次。 与超时一样，Istio 默认的重试行为在延迟方面可能不适合您的应用程序需求（对失败的服务进行过多的重试会降低速度）或可用性。 您可以在虚拟服务中按服务调整重试设置，而不必修改业务代码。 您还可以通过添加每次重试的超时来进一步细化重试行为，并指定每次重试都试图成功连接到服务所等待的时间量。 下面的示例配置了在首次调用失败后最多重试 3 次来连接到服务子集，每个重试都有 2 秒的超时。 apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: ratings spec: hosts: - ratings http: - route: - destination: host: ratings subset: v1 retries: attempts: 3 perTryTimeout: 2s 熔断 熔断是 Istio 为创建具有弹性的微服务应用提供的另一个有用的机制。 在熔断中，可以设置一个对服务中的单个主机调用的限制，例如并发连接的数量或对该主机调用失败的次数。 一旦限制被触发，熔断器就会“跳闸”并停止连接到该主机。使用熔断模式可以快速失败而不必让客户端尝试连接到过载或有故障的主机。 熔断适用于在负载均衡池中的“真实”网格目标地址，您可以在目标规则中配置熔断器阈值，让配置适用于服务中的每个主机。 下面的示例将 v1 子集的reviews服务工作负载的并发连接数限制为 100： apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: reviews spec: host: reviews subsets: - name: v1 labels: version: v1 trafficPolicy: connectionPool: tcp: maxConnections: 100 故障注入 在配置了网络，包括故障恢复策略之后，可以使用 Istio 的故障注入机制来为整个应用程序测试故障恢复能力。 故障注入是一种将错误引入系统以确保系统能够承受并从错误条件中恢复的测试方法。 使用故障注入特别有用，能确保故障恢复策略不至于不兼容或者太严格，这会导致关键服务不可用。 与其他错误注入机制（如延迟数据包或在网络层杀掉 Pod）不同，Istio 允许在应用层注入错误。 这使您可以注入更多相关的故障，例如 HTTP 错误码，以获得更多相关的结果。 您可以注入两种故障，它们都使用虚拟服务配置： 延迟：延迟是时间故障。它们模拟增加的网络延迟或一个超载的上游服务。 终止：终止是崩溃失败。他们模仿上游服务的失败。终止通常以 HTTP 错误码或 TCP 连接失败的形式出现。 例如，下面的虚拟服务为千分之一的访问 ratings 服务的请求配置了一个 5 秒的延迟： apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: ratings spec: hosts: - ratings http: - fault: delay: percentage: value: 0.1 fixedDelay: 5s route: - destination: host: ratings subset: v1 Istio 和应用程序同时工作 Istio 故障恢复功能对应用程序来说是完全透明的。 在返回响应之前，应用程序不知道 Envoy sidecar 代理是否正在处理被调用服务的故障。 这意味着，如果在应用程序代码中设置了故障恢复策略，那么您需要记住这两个策略都是独立工作的，否则会发生冲突。 例如，假设您设置了两个超时，一个在虚拟服务中配置，另一个在应用程序中配置。应用程序为服务的 API 调用设置了 2 秒超时。 而您在虚拟服务中配置了一个 3 秒超时和重试。 在这种情况下，应用程序的超时会先生效，因此 Envoy 的超时和重试尝试会失效。 虽然 Istio 故障恢复特性提高了网格中服务的可靠性和可用性，但应用程序必须处理故障或错误并采取适当的回退操作。 例如，当负载均衡中的所有实例都失败时，Envoy 返回一个HTTP 503代码。应用程序必须实现回退逻辑来处理HTTP 503错误代码。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap01/security.html":{"url":"chap01/security.html","title":"安全性","keywords":"","body":"安全性 将单一应用程序分解为微服务可提供各种好处，包括更好的灵活性、可伸缩性以及服务复用的能力。但是，微服务也有特殊的安全需求： 为了抵御中间人攻击，需要流量加密。 为了提供灵活的服务访问控制，需要双向 TLS 和细粒度的访问策略。 要确定谁在什么时候做了什么，需要审计工具。 Istio Security 尝试提供全面的安全解决方案来解决所有这些问题。 本文概述了如何使用 Istio 的安全功能来保护您的服务，无论您在何处运行它们。 特别是 Istio 安全性可以减轻针对您的数据、端点、通信和平台的内部和外部威胁。 Istio 安全功能提供强大的身份，强大的策略，透明的 TLS 加密，认证，授权和审计（AAA）工具来保护你的服务和数据。 Istio 安全方面的目标是： 默认就是安全的，应用程序代码和基础设施无需更改 与现有安全系统集成以提供多层防御 零信任网络：可以在不受信任的网络上构建安全解决方案 架构设计 Istio 身份认证 公钥基础设施（PKI） 认证流程 授权 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap01/observability.html":{"url":"chap01/observability.html","title":"可观测性","keywords":"","body":"可观测性 Istio 为网格内所有的服务通信生成详细的遥测数据。 这种遥测技术提供了服务行为的可观察性，使运维人员能够排查故障、维护和优化应用程序，而不会给服务的开发人员带来任何额外的负担。 通过 Istio，运维人员可以全面了解到受监控的服务如何与其他服务以及 Istio 组件进行交互。 Istio 生成以下类型的遥测数据，以提供对整个服务网格的可观察性： 指标: Istio 基于 4 个监控的黄金标识（延迟、流量、错误、饱和）生成了一系列服务指标。Istio 还为网格控制平面提供了更详细的指标。除此以外还提供了一组默认的基于这些指标的网格监控仪表板。 分布式追踪: Istio 为每个服务生成分布式追踪 span，运维人员可以理解网格内服务的依赖和调用流程。 访问日志: 当流量流入网格中的服务时，Istio 可以生成每个请求的完整记录，包括源和目标的元数据。此信息使运维人员能够将服务行为的审查控制到单个工作负载实例的级别。 下面，我们来依次进行讲解。 指标 指标（Metric）提供了一种以聚合的方式监控和理解行为的方法。 为了监控服务行为，Istio 为服务网格中所有出入网格，以及网格内部的服务流量都生成了指标。 这些指标提供了关于行为的信息，例如总流量数、错误率和请求响应时间。 除了监控网格中服务的行为外，监控网格本身的行为也很重要。 Istio 组件可以导出自身内部行为的指标，以提供对网格控制平面的功能和健康情况的洞察能力。 代理级别指标 Istio 指标收集从 sidecar 代理（Envoy）开始。 每个代理为通过它的所有流量（入站和出站）生成一组丰富的指标。 代理还提供关于它本身管理功能的详细统计信息，包括配置信息和健康信息。 Envoy 生成的指标提供了资源（例如监听器和集群）粒度上的网格监控。 因此，为了监控 Envoy 指标，需要了解网格服务和 Envoy 资源之间的连接。 Istio 允许运维人员在每个工作负载实例上选择生成和收集哪个 Envoy 指标。 默认情况下，Istio 只支持 Envoy 生成的统计数据的一小部分，以避免依赖过多的后端服务，还可以减少与指标收集相关的 CPU 开销。 然而，运维人员可以在需要时轻松地扩展收集到的代理指标集。 这支持有针对性地调试网络行为，同时降低了跨网格监控的总体成本。 代理级别指标的示例： envoy_cluster_internal_upstream_rq{response_code_class=\"2xx\",cluster_name=\"xds-grpc\"} 7163 envoy_cluster_upstream_rq_completed{cluster_name=\"xds-grpc\"} 7164 envoy_cluster_ssl_connection_error{cluster_name=\"xds-grpc\"} 0 envoy_cluster_lb_subsets_removed{cluster_name=\"xds-grpc\"} 0 envoy_cluster_internal_upstream_rq{response_code=\"503\",cluster_name=\"xds-grpc\"} 1 服务级别指标 除了代理级别指标之外，Istio 还提供了一组用于监控服务通信的面向服务的指标。 这些指标涵盖了四个基本的服务监控需求：延迟、流量、错误和饱和情况。 Istio 带有一组默认的仪表板，用于监控基于这些指标的服务行为。 默认的 Istio 指标由 Istio 提供的配置集定义并默认导出到 Prometheus。 运维人员可以自由地修改这些指标的形态和内容，更改它们的收集机制，以满足各自的监控需求。 收集指标任务为定制 Istio 指标生成提供了更详细的信息。 服务级别指标的使用完全是可选的。运维人员可以选择关闭指标的生成和收集来满足自身需要。 示例如下： istio_requests_total{ connection_security_policy=\"mutual_tls\", destination_app=\"details\", destination_canonical_service=\"details\", destination_canonical_revision=\"v1\", destination_principal=\"cluster.local/ns/default/sa/default\", destination_service=\"details.default.svc.cluster.local\", destination_service_name=\"details\", destination_service_namespace=\"default\", destination_version=\"v1\", destination_workload=\"details-v1\", destination_workload_namespace=\"default\", reporter=\"destination\", request_protocol=\"http\", response_code=\"200\", response_flags=\"-\", source_app=\"productpage\", source_canonical_service=\"productpage\", source_canonical_revision=\"v1\", source_principal=\"cluster.local/ns/default/sa/default\", source_version=\"v1\", source_workload=\"productpage-v1\", source_workload_namespace=\"default\" } 214 控制面指标 每一个 Istio 的组件（Pilot、Galley、Mixer）都提供了对自身监控指标的集合。 这些指标容许监控 Istio 自己的行为（这与网格内的服务有所不同）。 分布式追踪 分布式追踪通过监控流经网格的单个请求，提供了一种监控和理解行为的方法。 追踪使网格的运维人员能够理解服务的依赖关系以及在服务网格中的延迟源。 Istio 支持通过 Envoy 代理进行分布式追踪。 代理自动为其应用程序生成追踪 span，只需要应用程序转发适当的请求上下文即可。 Istio 支持很多追踪系统，包括 Zipkin、Jaeger、LightStep、Datadog。 运维人员控制生成追踪的采样率（每个请求生成跟踪数据的速率）。这允许运维人员控制网格生成追踪数据的数量和速率。 Istio 为一个请求生成的分布式追踪数据： 访问日志 访问日志提供了一种从单个工作负载实例的角度监控和理解行为的方法。 Istio 可以以一组可配置的格式集生成服务流量的访问日志，为运维人员提供日志记录的方式、内容、时间和位置的完全控制。 Istio 向访问日志机制暴露了完整的源和目标元数据，允许对网络通信进行详细的审查。 访问日志可以在本地生成，或者导出到自定义的后端基础设施，包括 Fluentd。 Istio 访问日志示例(JSON) 格式: { \"level\":\"info\", \"time\":\"2019-06-11T20:57:35.424310Z\", \"instance\":\"accesslog.instance.istio-control\", \"connection_security_policy\":\"mutual_tls\", \"destinationApp\":\"productpage\", \"destinationIp\":\"10.44.2.15\", \"destinationName\":\"productpage-v1-6db7564db8-pvsnd\", \"destinationNamespace\":\"default\", \"destinationOwner\":\"kubernetes://apis/apps/v1/namespaces/default/deployments/productpage-v1\", \"destinationPrincipal\":\"cluster.local/ns/default/sa/default\", \"destinationServiceHost\":\"productpage.default.svc.cluster.local\", \"destinationWorkload\":\"productpage-v1\", \"httpAuthority\":\"35.202.6.119\", \"latency\":\"35.076236ms\", \"method\":\"GET\", \"protocol\":\"http\", \"receivedBytes\":917, \"referer\":\"\", \"reporter\":\"destination\", \"requestId\":\"e3f7cffb-5642-434d-ae75-233a05b06158\", \"requestSize\":0, \"requestedServerName\":\"outbound_.9080_._.productpage.default.svc.cluster.local\", \"responseCode\":200, \"responseFlags\":\"-\", \"responseSize\":4183, \"responseTimestamp\":\"2019-06-11T20:57:35.459150Z\", \"sentBytes\":4328, \"sourceApp\":\"istio-ingressgateway\", \"sourceIp\":\"10.44.0.8\", \"sourceName\":\"ingressgateway-7748774cbf-bvf4j\", \"sourceNamespace\":\"istio-control\", \"sourceOwner\":\"kubernetes://apis/apps/v1/namespaces/istio-control/deployments/ingressgateway\", \"sourcePrincipal\":\"cluster.local/ns/istio-control/sa/default\", \"sourceWorkload\":\"ingressgateway\", \"url\":\"/productpage\", \"userAgent\":\"curl/7.54.0\", \"xForwardedFor\":\"10.128.0.35\" } By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap01/extensibility.html":{"url":"chap01/extensibility.html","title":"可扩展性","keywords":"","body":"可扩展性 WebAssembly 是一种沙盒技术，可以用于扩展 Istio 代理（Envoy）的能力。 Proxy-Wasm 沙盒 API 取代了 Mixer 作为 Istio 主要的扩展机制。 在 Istio 1.6 中将会为 Proxy-Wasm 插件提供一种统一的配置 API。 WebAssembly 沙盒的目标： 效率 - 这是一种低延迟，低 CPU 和内存开销的扩展机制。 功能 - 这是一种可以执行策略，收集遥测数据和执行有效荷载变更的扩展机制。 隔离 - 一个插件中程序的错误或是崩溃不会影响其它插件。 配置 - 插件使用与其它 Istio API 一致的 API 进行配置。可以动态的配置扩展。 运维 - 扩展可以以仅日志，故障打开或者故障关闭的方式进行访问和部署。 扩展开发者 - 可以用多种编程语言编写。 关于 WebAssembly 集成架构的介绍可以参考 视频 。 高级架构 示例 SDK 生态 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap02/quickstart.html":{"url":"chap02/quickstart.html","title":"快速入门","keywords":"","body":"Istio 环境快速搭建 本文可以帮助你快速搭建和试用Istio。 如果你对 Istio 已经非常熟悉，或者希望部署不同配置的Istio或者一些高级的部署模型 ，可以参考FAQ中我们应该怎么选择Istio的部署方式 。 在搭建 Istio 之前，你首先需要有一个正常运行的 K8s 集群，且 K8s 的版本与 Istio 版本兼容。 Istio版本 K8s版本 1.8 1.16, 1.17, 1.18, 1.19 1.9 1.17, 1.18, 1.19, 1.20 1.10 1.18, 1.19, 1.20, 1.21 下面，我们将按照如下步骤来开始使用 Istio: 下载并安装Istio 部署示例应用程序 对外开放应用程序 查看仪表盘 下载Istio Step1 转到 Istio 发布页面 ，下载针对你操作系统的安装文件。 或者也可以用自动化工具下载并提取最新版本（Linux 或 macOS）： curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.8.3 TARGET_ARCH=x86_64 sh - Step2 cd ./istio-1.8.3 在该目录下包含如下内容： 示例应用文件: samples/ 目录下。 istioctl 客户端: bin/ 目录下。 istio 配置相关配置文件: manifests/ 目录下。 Step3 将 istioctl 客户端所在目录添加至 PATH 环境变量中： export PATH=$PWD/bin:$PATH 安装Istio 接下来，我们使用 demo 的 配置 来进行 istio 的安装。 Ps: demo 的配置其实是一组专为测试/学习准备的功能集合，对于生产环境或性能要求较高的环境，建议选择其他配置。 istioctl install --set profile=demo -y # ✔ Istio core installed # ✔ Istiod installed # ✔ Egress gateways installed # ✔ Ingress gateways installed # ✔ Installation complete 当Istio安装完成后，我们还可以指定一些 namespace 可以默认自动注入 Envoy Sidecar 从来实现流量代理。 kubectl label namespace default istio-injection=enabled # namespace/default labeled 部署示例应用程序 当 Istio 部署完成后，我们就可以开始部署我们的示例应用程序了。 下面，我们以 书店应用程序 为例进行演示。 kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml 接下来，我们就要等待 bookinfo 中的每个 Pod 部署完成了，在部署的过程中，Istio 的 Sidecar 也会自动进行部署。 我们可以通过如下命令来查询部署的状态： kubectl get services kubectl get pods # NAME READY STATUS RESTARTS AGE # details-v1-5974b67c8-cq9vs 2/2 Running 0 3h28m # productpage-v1-64794f5db4-b9rdd 2/2 Running 0 3h28m # ratings-v1-c6cdf8d98-8wpfx 2/2 Running 0 3h28m # reviews-v1-7f6558b974-88z5n 2/2 Running 0 3h28m # reviews-v2-6cb6ccd848-jk65m 2/2 Running 0 3h28m # reviews-v3-cc56b578-wm5xl 2/2 Running 0 3h28m Ps: 再执行后续操作之前，需要先保证你的所有Pod都已经可以正常运行起来了。 下面，我们也可以通过运行如下命令来进行检查服务是否已经正常运行了： kubectl exec \"$(kubectl get pod -l app=ratings -o jsonpath='{.items[0].metadata.name}')\" -c ratings -- curl -s productpage:9080/productpage | grep -o \".*\" # Simple Bookstore App 对外开放应用程序 此时，bookinfo 应用其实在 K8s 集群中正常部署好了，但是它还不能被外部的服务进行访问。 为了让它可以被正常访问，我们需要创建一个 Istio 入口网关 ，它会在服务网格边缘把一个路径映射到我们的服务上。 kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml # gateway.networking.istio.io/bookinfo-gateway created # virtualservice.networking.istio.io/bookinfo created 接下来，我们可以使用 istioctl 工具来验证一下我们的配置是否正常: istioctl analyze 下面，我们来查一下我们入口网关的IP和端口。 首先，查询一下入口网关的HOST_IP： export INGRESS_HOST=$(kubectl get po -l istio=ingressgateway -n istio-system -o jsonpath='{.items[0].status.hostIP}') echo $INGRESS_HOST 它其实就是 ingressgateway Pod 所在的机器IP。 下面，我们再来查询一下入口网关的端口： export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==\"http2\")].nodePort}') echo $INGRESS_PORT export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==\"https\")].nodePort}') echo $SECURE_INGRESS_PORT 查询到了入口网关的IP和端口，那么，接下来，我们就可以组装得到入口网关的地址了： export GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT echo \"$GATEWAY_URL\" 为了验证该服务是否可以被外部服务正常访问，我们可以组装得到希望访问的URL，然后使用你的 WEB 浏览器打开看看吧： echo \"http://$GATEWAY_URL/productpage\" 查看仪表盘 Istio 内置集成了一系列遥测相关的应用。 这些遥测服务可以帮助我们理解服务网格的结构、展示网络的拓扑结构、分析网格的健康状态等。 下面，我们来部署一下 kiali 仪表盘。 kubectl apply -f samples/addons kubectl rollout status deployment/kiali -n istio-system # Waiting for deployment \"kiali\" rollout to finish: 0 of 1 updated replicas are available... # deployment \"kiali\" successfully rolled out Ps: kubectl apply 指令在第一次执行时，如果有一些 no matches for kind 类相关的报错的话，只需要再次重复执行一下即可，它们有时候和一些先后顺序有关。 完成 kiali 的部署后，我们可以给 kiali 提供一个访问入口： istioctl dashboard kiali # http://localhost:20001/kiali 上述命令可以申请一个端口，可以用于直接访问 kiali Dashboard页面。 进入 kiali Dashboard 页面后，在左侧的导航菜单，选择 Graph ，然后在 Namespace 下拉列表中，选择 default 。 Kiali 仪表板展示了网格的概览、以及 Bookinfo 示例应用的各个服务之间的关系。 它还提供过滤器来可视化流量的流动。 接下来 到此为止，我们其实就已经完成了 Istio 的环境搭建和体验。 对于新手来说，这些任务是非常好的资源，可以借助 demo 安装更深入了解 Istio 的特性： 请求路由 故障注入 流量切换 查询指标 可视化指标 访问外部服务 可视化网格 在你在生产环境使用 Istio 之前，请务必先阅读如下资源： 部署模型 部署的最佳实践 Pod 的需求 移除 Istio 删除 Bookinfo 示例应用和配置, 参阅 删除Bookinfo . Istio 卸载程序按照层次结构逐级的从 istio-system 命令空间中删除 RBAC 权限和所有资源。对于不存在的资源报错，可以安全的忽略掉，毕竟他们已经被分层的删除了。 kubectl delete -f samples/addons istioctl manifest generate --set profile=demo | kubectl delete --ignore-not-found=true -f - 命名空间 istio-system 默认情况下并不会被删除。 不需要的时候，使用下面命令删掉它： kubectl delete namespace istio-system 指示 Istio 自动注入 Envoy 边车代理的标签默认也不删除。 不需要的时候，使用下面命令删掉它。 kubectl label namespace default istio-injection- By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap02/config_profiles.html":{"url":"chap02/config_profiles.html","title":"补充说明","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap04/first_example.html":{"url":"chap04/first_example.html","title":"快速入门","keywords":"","body":"快速入门 在本文中，我们将会以一个非常简单的入门示例来演示关于 VirtualService 和 DestinationRule 相关的基本概念。 基础环境准备 首先，为了演示该实例，我们首先来创建一个新的 namespace 并将该 namespace 设置为自动注入 sidecar 。 kubectl create ns books kubectl label namespace books istio-injection=enabled 业务服务部署 下面，我们来部署对应的业务容器，该业务容器是一个 Flask 服务，可以通过 url 查询它对应的环境变量。 其中，业务容器的镜像为: dustise/flaskapp 下面，我们准备一个 flaskapp.yaml 的文件，该文件中包含了 flaskdemo 的 deployment 定义与对应的 service 定义。 apiVersion: v1 kind: Service metadata: name: flaskapp labels: app: flaskapp spec: selector: app: flaskapp ports: - name: http port: 80 --- apiVersion: apps/v1 kind: Deployment metadata: name: flaskapp-v1 spec: selector: matchLabels: app: flaskapp version: v1 replicas: 1 template: metadata: labels: app: flaskapp version: v1 spec: containers: - name: flaskapp image: dustise/flaskapp imagePullPolicy: IfNotPresent env: - name: version value: v1 --- apiVersion: apps/v1 kind: Deployment metadata: name: flaskapp-v2 spec: selector: matchLabels: app: flaskapp version: v2 replicas: 1 template: metadata: labels: app: flaskapp version: v2 spec: containers: - name: flaskapp image: dustise/flaskapp imagePullPolicy: IfNotPresent env: - name: version value: v2 然后创建业务容器： kubectl apply -f flaskapp.yaml -n books 下面，有个业务容器之后，我们再来创建一个客户端容器，用于向业务容器发起访问。 客户端容器的镜像非常简单，只安装了一个 curl 等相关的指令，镜像为: dustise/sleep 下面，我们准备了一个 client.yaml 的文件，该文件包含了对应客户端文件的 deployment 的定义： apiVersion: apps/v1 kind: Deployment metadata: name: sleep spec: selector: matchLabels: app: sleep version: v1 replicas: 1 template: metadata: labels: app: sleep version: v1 spec: containers: - name: sleep image: dustise/sleep imagePullPolicy: IfNotPresent 然后创建客户端部署对象： kubectl apply -f client.yaml -n books 下面，我们就可以进入客户端的容器了： kubectl exec -it sleep-7575b5d557-n68b4 -c sleep bash -n books 然后在容器内可以执行如下命令来访问业务容器： for i in `seq 10`; do http --body http://flaskapp.book/env/version; done 此时，查看请求返回的结果，我们应该可以看到，v1 和 v2 的业务容器基本上是均匀被访问，这是 K8s Service 中提供的基本的负载均衡访问的能力。 创建 VirtualService 和 DestinationRule 下面，我们就来体验一下 Istio 相关的功能吧，之前的基本概念中，我们已经了解了 DestinationRule 和 VirtualService 的基本概念， 我们就来在实际应用中应用一下吧。 首先，我们来创建 flaskapp 应用的 DestinationRule，它可以将应用分为多个子网，然后在 VirtualService 可以指定到对应的子网请求。 首先，我们准备一个 destination_rule.yaml 文件： apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: flaskapp spec: host: flaskapp subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2 在该 destination_rule 的配置文件中，我们将对应的 flaskapp 服务下面的 Pod 安装 label 中 version 字段的不同， 分为了 v1 和 v2 两个子集。 下面，我们再来创建一个 virtual_service.yaml 文件： apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: flaskapp-policy spec: hosts: - flaskapp http: - route: - destination: host: flaskapp subset: v2 通过 VirtualService 的配置，我们可以将该所有请求至 flaskapp Service 的请求，按照对应的规则发送给对应的目的下游。 其中，在上述的规则配置中，我们将 flaskapp Service 的请求全部转发给了 flaskapp 下对应的 v2 子集下的实例。 下面，我们应用一下这两个配置文件： kubectl apply -f client.destination_rule -n books kubectl apply -f virtual_service.yaml -n books 验证相关的效果 当对应的 VirtualService 和 DestinationRule 的规则都配置完成后，下面，我们就可以来验证一下效果了。 再次在客户端容器内请求业务容器试试： for i in `seq 10`; do http --body http://flaskapp.books/env/version; done 可以看到此时返回的结果预期应该已经全部都是 v2 了，对！我们的流量控制已经生效了。 下面，我们还可以修改一下 virtual_service.yaml 文件的规则，将请求流量都转到 v1 子集上，然后重新 apply 生效： kubectl apply -f virtual_service.yaml -n books 再次请求一下看看吧，响应是否已经都切回到v1了？ By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap04/bookinfo.html":{"url":"chap04/bookinfo.html","title":"书店应用","keywords":"","body":"书店应用 Istio 化 在本文中，我们将会以一个示例项目为例，来演示多种 Istio 特性功能的应用。 项目概述 在该示例项目中，包含四个单独的微服务。 这个应用模仿在线书店的一个分类，显示一本书的信息。 页面上会显示一本书的描述，书籍的细节（ISBN、页数等），以及关于这本书的一些评论。 Bookinfo 应用分为四个单独的微服务： productpage: 这个微服务会调用 details 和 reviews 两个微服务，用来生成页面。 details: 这个微服务中包含了书籍的信息。 reviews: 这个微服务中包含了书籍相关的评论。它还会调用 ratings 微服务。 ratings: 这个微服务中包含了由书籍评价组成的评级信息。 其中，reviews 微服务有 3 个版本： v1 版本不会调用 ratings 服务。 v2 版本会调用 ratings 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。 v3 版本会调用 ratings 服务，并使用 1 到 5 个红色星形图标来显示评分信息。 下图展示了这个应用的端到端架构： Bookinfo 应用中的几个微服务是由不同的语言编写的。 这些服务对 Istio 并无依赖，但是构成了一个有代表性的服务网格的例子：它由多个服务、多个语言构成，并且 reviews 服务具有多个版本。 在正式开始之前，首先你需要完整搭建一套 K8s 环境并部署完成 Istio 。 应用部署 要在 Istio 中运行这一应用，无需对应用自身做出任何改变。 您只要简单的在 Istio 环境中对服务进行配置和运行，具体一点说就是把 Envoy sidecar 注入到每个服务之中。 最终的部署结果将如下图所示： 所有的微服务都和 Envoy sidecar 集成在一起，被集成服务所有的出入流量都被 sidecar 所劫持， 这样就为外部控制准备了所需的 Hook，然后就可以利用 Istio 控制平面为应用提供服务路由、遥测数据收集以及策略实施等功能。 具体来说： Step1: 为 default 命名空间设置为自动注入 Istio 。 kubectl label namespace default istio-injection=enabled Step2: 部署 Bookinfo 应用： kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml 上面的命令会启动全部的四个服务，其中也包括了 reviews 服务的三个版本（v1、v2 以及 v3）。 Ps: 在实际部署中，微服务版本的启动过程需要持续一段时间，并不是同时完成的。 Step3: 确认所有的服务和 Pod 都已经正确的定义和启动： kubectl get services kubectl get pods Step4: 要确认 Bookinfo 应用是否正在运行，请在某个 Pod 中用 curl 命令对应用发送请求，例如 ratings： kubectl exec -it $(kubectl get pod -l app=ratings -o jsonpath='{.items[0].metadata.name}') -c ratings -- curl productpage:9080/productpage | grep -o \".* Step5: 确定 Ingress 的 IP 和端口 现在 Bookinfo 服务启动并运行中，您需要使应用程序可以从外部访问 Kubernetes 集群，例如使用浏览器。可以用 Istio Gateway 来实现这个目标。 kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml kubectl get gateway 查询网关的 INGRESS_HOST 和 INGRESS_PORT 变量，确认并设置： export INGRESS_HOST=$(kubectl get po -l istio=ingressgateway -n istio-system -o jsonpath='{.items[0].status.hostIP}') echo $INGRESS_HOST export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==\"http2\")].nodePort}') echo $INGRESS_PORT export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==\"https\")].nodePort}') echo $SECURE_INGRESS_PORT export GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT echo \"$GATEWAY_URL\" Step6: 从集群外部访问应用 当我们得到 $GATEWAY_URL 之后，就可以通过浏览器从集群外部来访问集群资源了。 我们可以用浏览器打开网址 http://$GATEWAY_URL/productpage ，来浏览应用的 Web 页面。如果刷新几次应用的页面， 就会看到 productpage 页面中会随机展示 reviews 服务的不同版本的效果（红色、黑色的星形或者没有显示）。 reviews 服务出现这种情况是因为我们还没有使用 Istio 来控制版本的路由。 应用默认目标规则 在使用 Istio 控制 Bookinfo 版本路由之前，您需要在目标规则中定义好可用的版本，命名为 subsets 。 运行以下命令为 Bookinfo 服务创建的默认的目标规则： kubectl apply -f samples/bookinfo/networking/destination-rule-all.yaml 等待几秒钟，以使目标规则生效。 可以使用以下命令查看目标规则： kubectl get destinationrules -o yaml 至此为止，我们就完成了 Istio 实验的基本环境准备工作，接下来，我们就可以使用这一应用来体验 Istio 的特性了，其中包括了流量的路由、错误注入、速率限制等。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/traffic_management.html":{"url":"chap03/traffic_management.html","title":"流量控制","keywords":"","body":"流量控制 流量管理和控制可以说是 Istio 中最核心的功能了。 在本系列文章中，会依次对 Istio 中流量路由相关的功能进行演示。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/request_routing.html":{"url":"chap03/request_routing.html","title":"请求路由","keywords":"","body":"请求路由 请求路由是指将请求动态路由到微服务的多个不同的版本上。 在之前的 示例 中，我们已经部署完成了 Bookinfo 应用。 下面，将会基于 Bookinfo 应用来演示如果使用 Istio 来控制请求路由。 在之前的示例中，其中一个微服务 reviews 的三个不同版本已经部署并同时运行。 这导致在浏览器中访问 Bookinfo 应用程序的 /productpage 并刷新几次， 有时书评的输出包含星级评分，有时则不包含。 这是因为没有明确的默认服务版本可路由，Istio 将以循环方式将请求路由到所有可用版本。 下面，我们将会在本文中，我们会先将所有流量都路由到 reviews 的 v1 版本， 然后在演示如何根据 HTTP header 的值来进行流量路由。 将所有流量都路由到 reviews 的 v1 版本 首先，我们希望将所有访问 reviews 的请求全部路由到 v1 版本时， 我们需要为微服务 reviews 设置一个默认版本的 VirtualService 。 在 VirtualService 中，我们可以指定流量路由到的实例版本。 kubectl apply -f samples/bookinfo/networking/virtual-service-all-v1.yaml 由于配置传播是最终一致的，因此请等待几秒钟以使 Virtual Service 生效。 可以查询一下看到如下结果： apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: productpage spec: hosts: - productpage http: - route: - destination: host: productpage subset: v1 --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews spec: hosts: - reviews http: - route: - destination: host: reviews subset: v1 --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: ratings spec: hosts: - ratings http: - route: - destination: host: ratings subset: v1 --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: details spec: hosts: - details http: - route: - destination: host: details subset: v1 --- 此时，我们已将 Istio 配置为路由到 Bookinfo 微服务的 v1 版本，最重要的是 reviews 服务的版本 1。 您可以通过再次刷新 Bookinfo 应用程序的 /productpage 轻松测试新配置。 无论您刷新多少次，页面的评论部分都不会显示评级星标。这是因为您将 Istio 配置为将评论服务的所有流量路由到版本 reviews:v1， 而此版本的服务不访问星级评分服务。 根据 HTTP header 的值来进行流量路由 下面，我们来进行一个更加『高级』的功能，更改路由配置，以便将来自特定用户的所有流量路由到特定服务版本。 例如，我们可以将来自名为 Jason 的用户的所有流量将被路由到服务 reviews:v2。 Ps: Istio 对用户身份没有任何特殊的内置机制。 事实上，productpage 服务在所有到 reviews 服务的 HTTP 请求中都增加了一个自定义的 end-user 请求头，从而达到了本例子的效果。 我们可以运行以下命令以启用基于用户的路由： kubectl apply -f samples/bookinfo/networking/virtual-service-reviews-test-v2.yaml 其中配置如下: apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews spec: hosts: - reviews http: - match: - headers: end-user: exact: jason route: - destination: host: reviews subset: v2 - route: - destination: host: reviews subset: v1 在 Bookinfo 应用程序的 /productpage 上，以用户 jason 身份登录，刷新浏览器。您看到了什么？星级评分显示在每个评论旁边。 然后以其他用户身份登录（选择您想要的任何名称）， 刷新浏览器。现在星星消失了。这是因为除了 Jason 之外，所有用户的流量都被路由到 reviews:v1。 原理概述 在此任务中，您首先使用 Istio 将 100% 的请求流量都路由到了 Bookinfo 服务的 v1 版本。 然后设置了一条路由规则，它根据 productpage 服务发起的请求中的 end-user 自定义请求头内容， 选择性地将特定的流量路由到了 reviews 服务的 v2 版本。 请注意，Kubernetes 中的服务，如本任务中使用的 Bookinfo 服务，必须遵守某些特定限制，才能利用到 Istio 的 L7 路由特性优势。 参考 Pod 和 Service 需求 了解详情。 在下一节流量转移任务中，您将按照在此处学习到的相同的基本模式来配置路由规则，以逐步将流量从服务的一个版本迁移到另一个版本。 环境恢复 该实验完成后，为了恢复初识状态，我们可以删除对应的 VirtualService 。 kubectl delete -f samples/bookinfo/networking/virtual-service-all-v1.yaml 再次刷新页面，可以看到评分显示的状态又在不断的变化了。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/fault_injection.html":{"url":"chap03/fault_injection.html","title":"故障注入","keywords":"","body":"故障注入 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/traffic_shifting.html":{"url":"chap03/traffic_shifting.html","title":"流量转移","keywords":"","body":"流量转移 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/tcp_traffic_shifting.html":{"url":"chap03/tcp_traffic_shifting.html","title":"TCP流量转移","keywords":"","body":"TCP流量转移 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/timeout.html":{"url":"chap03/timeout.html","title":"请求超时","keywords":"","body":"请求超时 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/circuit_breaking.html":{"url":"chap03/circuit_breaking.html","title":"熔断","keywords":"","body":"熔断 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/mirroring.html":{"url":"chap03/mirroring.html","title":"镜像流量","keywords":"","body":"镜像流量 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/ingress.html":{"url":"chap03/ingress.html","title":"入口流量","keywords":"","body":"入口流量 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/egress.html":{"url":"chap03/egress.html","title":"出口流量","keywords":"","body":"出口流量 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/observability.html":{"url":"chap03/observability.html","title":"可观测性","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/metrics.html":{"url":"chap03/metrics.html","title":"可视化指标","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/log.html":{"url":"chap03/log.html","title":"日志","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/tracing.html":{"url":"chap03/tracing.html","title":"分布式追踪","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap03/visualizing_mesh.html":{"url":"chap03/visualizing_mesh.html","title":"可视化网格","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/deployment.html":{"url":"chap05/deployment.html","title":"部署方式","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/architecture.html":{"url":"chap05/architecture.html","title":"架构","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/deployment_models.html":{"url":"chap05/deployment_models.html","title":"部署模型","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/requirements.html":{"url":"chap05/requirements.html","title":"Pod和Service约束","keywords":"","body":"Pod 和 Service 约束 作为 Istio 服务网格中的一部分，Kubernetes 集群中的 Pod 和 Service 必须满足以下要求： 命名的服务端口: Service 的端口必须命名。端口名键值对必须按以下格式：name: [-]。 Service 关联: 每个 Pod 必须至少属于一个 Kubernetes Service，不管这个 Pod 是否对外暴露端口。如果一个 Pod 同时属于多个 Kubernetes Service， 那么这些 Service 不能同时在一个端口号上使用不同的协议（比如：HTTP 和 TCP）。 我们建议显式地给 Deployment 加上 app 和 version 标签。给使用 Kubernetes Deployment 部署的 Pod 部署配置中增加这些标签，可以给 Istio 收集的指标和遥测信息中增加上下文信息。 应用 UID: 确保你的 Pod 不会以用户 ID（UID）为 1337 的用户运行应用。 NET_ADMIN 功能: 如果你的集群执行 Pod 安全策略，必须给 Pod 配置 NET_ADMIN 功能。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/best_practice.html":{"url":"chap05/best_practice.html","title":"最佳实践","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/deployment_best_practice.html":{"url":"chap05/deployment_best_practice.html","title":"部署最佳实践","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/integration.html":{"url":"chap05/integration.html","title":"应用集成","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/grafana.html":{"url":"chap05/grafana.html","title":"Grafana","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/jaegar.html":{"url":"chap05/jaegar.html","title":"Jaeger","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/kiali.html":{"url":"chap05/kiali.html","title":"Kiali","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/prometheus.html":{"url":"chap05/prometheus.html","title":"Prometheus","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap05/zipkin.html":{"url":"chap05/zipkin.html","title":"Zipkin","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap06/config.html":{"url":"chap06/config.html","title":"配置","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap06/virtual_service.html":{"url":"chap06/virtual_service.html","title":"流量管理之 VirtualService","keywords":"","body":"VirtualService 配置详解 基本概念 Service 是绑定到服务注册表中唯一名称的应用程序行为单元。 Service 由在 pod、容器、VM 等上运行的工作负载实例实现的多个网络端点组成。 Service Version(称之为 subset) 是指在持续部署场景中，对于给定的服务，可以有不同的实例子集，它们运行着的应用程序二进制文件的版本可能不同。 例如，它们提供的 API 的版本可能不同，它们也可以是对同一服务的迭代更改，部署在不同的环境（生产、暂存、开发等）中。 其中，A/B 测试、金丝雀发布等常用场景其实就是利用着相关的特性。 在 VirtualService 中，可以通过各种规则（例如url, headers）等来决定访问具体不同版本的权重。 此外，对于每个 VirtualService 而言，默认情况下会将请求发给它的所有实例。 Source 是指调用服务的下游客户端。 Host 是指客户端尝试连接到服务时使用的地址。 Access model 下游服务在访问目标时，仅仅需要指标目标服务的地址（Host），而不需要了解单个服务版本（Subset）， 而具体请求下发到哪个版本的实例上面，则是有 Sidecar 来进行决策，从而使得应用程序代码能够将自身与依赖服务的演变进行解耦。 VirtualService 定义了一组要在访问 host 时应用的流量路由规则，每个路由规则定义了特定协议流量的匹配规则。 如果流量的匹配规则满足的话，则将其发送到配置中定义的目标服务（或其子集/版本）中。 请求来源也可以在路由规则中进行条件匹配，通过这一机制，可以实现为特定客户端定制路由机制。 以下 Kubernetes 示例默认将所有 HTTP 流量路由到带有标签“version: v1”的评论服务的 pod。 此外，url以 /wpcatalog/ 或 /consumercatalog/ 开头的 HTTP 请求将被重写为 /newcatalog 并发送到标签为“version: v2”的 pod。 apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews-route spec: hosts: - reviews.prod.svc.cluster.local http: - name: \"reviews-v2-routes\" match: - uri: prefix: \"/wpcatalog\" - uri: prefix: \"/consumercatalog\" rewrite: uri: \"/newcatalog\" route: - destination: host: reviews.prod.svc.cluster.local subset: v2 - name: \"reviews-v1-route\" route: - destination: host: reviews.prod.svc.cluster.local subset: v1 其中，路由目的地的子集/版本通过对命名服务子集的引用来标识，该子集必须在相应的 DestinationRule 中声明，示例如下： apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: reviews-destination spec: host: reviews.prod.svc.cluster.local subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2 下面，我们来对其中的一些核心配置字段的配置信息来依次进行详细的说明。 VirtualService 字段 类型 字段功能描述 是否必填 hosts string[] 流量的目标主机，可以是带有通配符前缀的DNS名称，也可以是IP地址。根据所在平台情况，还可能使用短名称来代替FQDN。这种场景下，短名称到 FQDN 的具体转换过程是要靠下层平台完成的。一个 VirtualService 中可以用于控制多个 HTTP 和 TCP 端口的流量属性，反之，一个目标地址的流量属性也可以同时在多个 VirtualService 中进行定义。对于K8s用户而言，当使用短服务名（如reviews，而不是reviews.default.svc.cluster.local）时，Istio会将短服务名与 VirtualService 定义所属的namespace来进行拼接，而不是K8s Service本身所属的namespace。为了避免潜在的错误配置，建议始终使用完全限定域名而不是短名称。hosts 字段适用于 HTTP 和 TCP 服务。网格内的服务，即在服务注册表中找到的服务，必须始终使用它们的字母数字名称来引用。 IP 地址只允许用于通过网关定义的服务。 是 gateways string[] VirtualService 对象可以用于网格中的 Sidecar，也可以用于一个或多个 Gateway。这里公开的选择条件可以在协议相关的路由过滤条件中进行覆盖。保留字 mesh 用来指代网格中的所有 Sidecar。当这一字段被省略时，就会使用缺省值（mesh），也就是针对网格中的所有 Sidecar 生效。如果提供了 gateways 字段，这一规则就只会应用到声明的 Gateway 之中。要让规则同时对 Gateway 和网格内服务生效，需要显式的将 mesh 加入 gateways 列表。 否 http HTTPRoute[] HTTP 流量规则的有序列表。这个列表对名称前缀为 http-、http2-、grpc- 的服务端口，或者协议为 HTTP、HTTP2、GRPC 以及终结的 TLS，另外还有使用 HTTP、HTTP2 以及 GRPC 协议的 ServiceEntry 都是有效的。进入流量会使用匹配到的第一条规则。 否 tls TLSRoute[] 一个有序列表，对应的是透传 TLS 和 HTTPS 流量。路由过程通常利用 ClientHello 消息中的 SNI 来完成。TLS 路由通常应用在 https-、tls- 前缀的平台服务端口，或者经 Gateway 透传的 HTTPS、TLS 协议端口，以及使用 HTTPS 或者 TLS 协议的 ServiceEntry 端口上。注意：没有关联 VirtualService 的 https- 或者 tls- 端口流量会被视为透传 TCP 流量。 否 tcp TCPRoute[] 不透明 TCP 流量的路由规则的有序列表。 TCP 路由将应用于非 HTTP 或 TLS 端口的任何端口。使用匹配传入请求的第一个规则。 否 exportTo string[] 此VirtualService可见的namespace列表。导出VirtualService允许它被其他namespace中定义的sidecar和网关使用。此功能为服务所有者和网格管理员提供了一种机制来控制跨namespace边界的VirtualService的可见性。如果未指定namespace，则默认情况下将VirtualService导出到所有namespace。设置为.表示导出到声明VirtualService的相同namespace。类似地，值“”被保留并定义到所有namespace的导出。注意：在当前版本中，exportTo 值被限制为“.”。或“”（即当前namespace或所有namespace）。 否 HTTPRoute 描述路由 HTTP/1.1、HTTP2 和 gRPC 流量的匹配条件和操作。 字段 类型 字段功能描述 是否必填 name string 为调试目的分配给路由的名称。路由的名称将与匹配的名称连接，并将记录在与此路由/匹配匹配的请求的访问日志中。 否 match HTTPMatchRequest[] 匹配规则要满足的匹配条件。单个匹配块内的所有条件都具有 AND 语义，而匹配块列表具有 OR 语义。 否 route HTTPRouteDestination[] http 规则可以重定向或转发（默认）流量。转发目标可以是服务的多个版本之一。与服务版本相关的权重决定了它接收的流量比例。 否 redirect HTTPRedirect http 规则可以重定向或转发（默认）流量。如果规则中指定了流量透传选项，路由/重定向将被忽略。重定向原语可用于将 HTTP 301 重定向发送到不同的 URI 或权限。 否 rewrite HTTPRewrite 重写 HTTP URI 和权限标头。 Rewrite 不能与 Redirect 原语一起使用。在转发之前将执行重写。 否 timeout Duration HTTP请求的超时时间。 否 retries HTTPRetry HTTP请求的重试策略。 否 fault HTTPFaultInjection 应用于客户端 HTTP 流量的故障注入策略。请注意，在客户端启用故障时，将不会启用超时或重试。 否 mirror Destination 除了将请求转发到预期目的地之外，还可以将 HTTP 流量镜像到另一个目的地。镜像流量只是会尽量保证镜像流量发送，不会等待镜像集群的响应信息。 否 mirrorPercent uint 32 镜像字段要镜像的流量的百分比。如果此字段不存在，则所有流量 (100%) 都将被镜像。最大值为 100。 否 corsPolicy CorsPolicy 跨源资源共享策略 (CORS)。 否 headers Headers headers的处理规则。 否 HTTPMatchRequest HttpMatchRequest 指定一组要满足的标准，以便将规则应用于 HTTP 请求。 例如，以下规则将规则限制为仅匹配 URL 路径以 /ratings/v2/ 开头且请求头中包含 end-user 字段的值为 jason 的请求。 apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: ratings-route spec: hosts: - ratings.prod.svc.cluster.local http: - match: - headers: end-user: exact: jason uri: prefix: \"/ratings/v2/\" ignoreUriCase: true route: - destination: host: ratings.prod.svc.cluster.local HTTPMatchRequest 字段不允许为空。 字段 类型 字段功能描述 是否必填 name string 分配给匹配项的名称。匹配的名称将与父路由的名称连接，并将记录在与此路由匹配的请求的访问日志中。 否 uri StringMatch 匹配值的 URI 默认区分大小写，格式如下：exact 表示精确匹配，prefix 表示前缀匹配，regex 表示正则匹配。注意：可以通过 ignore_uri_case 标志启用不区分大小写的匹配。 否 scheme StringMatch URI Scheme 值区分大小写。 否 method StringMatch HTTP 方法区分大小写。 否 authority StringMatch HTTP 权限值区分大小写。 否 headers map header中的key必须是小写且使用-来分隔，例如 x-request-id。 否 port uint32 指定要寻址的主机上的端口。许多服务仅公开单个端口或带有它们支持的协议的标签端口，在这些情况下，不需要明确选择端口。 否 sourceLabels map 一个或多个标签，用于限制规则对具有给定标签的工作负载的场景。如果 VirtualService 设置了 gateways，则它必须包含mesh以使该字段适用。 否 queryParams map 对query请求的参数进行匹配。 否 ignoreUriCase bool 指定uri匹配中是否区分大小写，默认为否。 否 HTTPRouteDestination 每个路由规则都与一个或多个服务版本相关联。与版本相关的权重决定了它接收的流量比例。 例如，以下规则将“评论”服务的 25% 流量路由到带有“v2”标签的实例，其余流量（即 75%）路由到“v1”。 apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews-route spec: hosts: - reviews.prod.svc.cluster.local http: - route: - destination: host: reviews.prod.svc.cluster.local subset: v2 weight: 25 - destination: host: reviews.prod.svc.cluster.local subset: v1 weight: 75 此外，也可以将流量分为两个完全不同的服务，而无需定义新的子集。 例如，以下规则将 25% 的流量转发到 review.com 到 dev.reviews.com 。 apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews-route-two-domains spec: hosts: - reviews.com http: - route: - destination: host: dev.reviews.com weight: 25 - destination: host: reviews.com weight: 75 字段 类型 字段功能描述 是否必填 destination Destination Destination 唯一标识了请求/连接应该转发到的服务实例。 是 weight int32 要转发到服务版本的流量比例(0-100)。跨目的地的权重总和应该 == 100。如果规则中只有一个目的地，则假定权重值为100。 否 headers Headers 设置Header的操作规则。 否 Destination Destination 表示处理路由规则后请求/连接将发送到的网络可寻址服务。 destination.host 应该明确引用服务注册表中的服务。 Istio 的服务注册表由平台服务注册表中的所有服务（例如 Kubernetes 服务、Consul 服务）以及通过 ServiceEntry 资源声明的服务组成。 Kubernetes 用户注意事项：当使用短名称时（例如“reviews”而不是“reviews.default.svc.cluster.local”）， Istio 将根据规则的命名空间而不是服务来解释短名称。 为避免潜在的错误配置，建议始终使用完全限定域名而不是短名称。 以下 Kubernetes 示例默认将所有流量路由到 Kubernetes 环境中带有标签“version: v1”（即子集 v1）的评论服务的 Pod，以及一些到子集 v2 的流量。 apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews-route namespace: foo spec: hosts: - reviews # interpreted as reviews.foo.svc.cluster.local http: - match: - uri: prefix: \"/wpcatalog\" - uri: prefix: \"/consumercatalog\" rewrite: uri: \"/newcatalog\" route: - destination: host: reviews # interpreted as reviews.foo.svc.cluster.local subset: v2 - route: - destination: host: reviews # interpreted as reviews.foo.svc.cluster.local subset: v1 它对应的 DestinationRule 如下： apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: reviews-destination namespace: foo spec: host: reviews # interpreted as reviews.foo.svc.cluster.local subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2 以下 VirtualService 为 Kubernetes 中对 productpage.prod.svc.cluster.local 服务的所有调用设置了 5 秒的超时。 请注意，此规则中没有定义子集。 Istio 将从服务注册表中获取 productpage.prod.svc.cluster.local 服务的所有实例。 另外需要注意，此规则设置在 istio-system 命名空间中，但使用 productpage 服务的完全限定域名 productpage.prod.svc.cluster.local。 因此，规则的命名空间对解析 productpage 服务的名称没有影响。 apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: my-productpage-rule namespace: istio-system spec: hosts: - productpage.prod.svc.cluster.local # ignores rule namespace http: - timeout: 5s route: - destination: host: productpage.prod.svc.cluster.local 为了控制绑定到网格外部服务的流量的路由，必须首先使用 ServiceEntry 资源将外部服务添加到 Istio 的内部服务注册表。 然后可以定义 VirtualServices 来控制绑定到这些外部服务的流量。 例如，以下规则为 wikipedia.org 定义了一个服务，并为 http 请求设置了 5 秒的超时时间。 apiVersion: networking.istio.io/v1alpha3 kind: ServiceEntry metadata: name: external-svc-wikipedia spec: hosts: - wikipedia.org location: MESH_EXTERNAL ports: - number: 80 name: example-http protocol: HTTP resolution: DNS --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: my-wiki-rule spec: hosts: - wikipedia.org http: - timeout: 5s route: - destination: host: wikipedia.org Ps: ServiceEntry 可以将外部服务的访问地址或域名引入Istio中。 字段 类型 字段功能描述 是否必填 host string 来自服务注册中心的服务名称。服务名称是从平台的服务注册表（例如 Kubernetes 服务、Consul 服务等）和 ServiceEntry 声明的主机中查找的。如果配置的host在平台服务注册表和ServiceEntry中都没有，则流量会被丢弃。 是 subset string 服务中子集的名称。仅适用于网格内的服务。该子集必须在相应的 DestinationRule 中定义。 否 port PortSelector 指定要寻址的主机上的端口。如果服务仅公开一个端口，则不需要显式选择该端口。 否 PortSelector PortSelector 指定用于匹配或选择最终路由的端口号。 字段 类型 字段功能描述 是否必填 number uint32 正确的端口号 否 HTTPRedirect HTTPRewrite Duration HTTPRetry HTTPFaultInjection Headers 当 Envoy 将请求转发到目标服务或从目标服务转发响应时，可以修改消息头。 可以为特定路由目的地或所有目的地指定标头操作规则。 以下 VirtualService 向路由到任何评论服务目标的请求添加了一个值为 test=true 的 headers。 它还删除 foo 响应标头，但仅来自来自评论服务的 v1 子集（版本）的响应。 apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews-route spec: hosts: - reviews.prod.svc.cluster.local http: - headers: request: set: test: true route: - destination: host: reviews.prod.svc.cluster.local subset: v2 weight: 25 - destination: host: reviews.prod.svc.cluster.local subset: v1 headers: response: remove: - foo weight: 75 headers 的处理操作可以出现在 HTTPRoute 块，也可以出现在 HTTPRouteDestination 块中。 字段 类型 字段功能描述 是否必填 request HeaderOperations 在将请求转发到目标服务之前对请求headers的操作规则 否 response HeaderOperations 在向调用者返回响应之前要应用的headers操作规则 否 HeaderOperations 字段 类型 字段功能描述 是否必填 set map 用给定的map重写header中对应的key 否 add map 向headers中添加给定的map信息 否 remove string[] 删除headers中指定的字段 否 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap06/destination_rule.html":{"url":"chap06/destination_rule.html","title":"流量管理之 DestinationRule","keywords":"","body":"DestinationRule 配置详解 基本概念 DestinationRule 定义了在路由发生后应用于服务流量的策略。 这些规则指定负载均衡的配置、来自 sidecar 的连接池大小和异常检测设置，以检测和从负载均衡池中驱逐不健康的实例。 例如，ratings 服务的简单负载均衡策略如下所示： apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: bookinfo-ratings spec: host: ratings.prod.svc.cluster.local trafficPolicy: loadBalancer: simple: LEAST_CONN 可以通过定义命名子集并覆盖在服务级别指定的设置来指定特定于版本的策略。 以下规则对所有流向名为 testversion 的子集的流量使用循环负载均衡策略，该子集由带有标签 (version:v3) 的端点（例如 pod）组成。 apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: bookinfo-ratings spec: host: ratings.prod.svc.cluster.local trafficPolicy: loadBalancer: simple: LEAST_CONN subsets: - name: testversion labels: version: v3 trafficPolicy: loadBalancer: simple: ROUND_ROBIN 注意：在路由规则明确将流量发送到该子集之前，为子集指定的策略不会生效。 流量策略也可以针对特定端口进行定制。以下规则对到端口 80 的所有流量使用最少连接负载均衡策略，而对到端口 9080 的流量使用循环负载均衡设置。 apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: bookinfo-ratings-port spec: host: ratings.prod.svc.cluster.local trafficPolicy: # Apply to all ports portLevelSettings: - port: number: 80 loadBalancer: simple: LEAST_CONN - port: number: 9080 loadBalancer: simple: ROUND_ROBIN DestinationRule DestinationRule 定义了在路由发生后应用于服务流量的策略。 字段 类型 字段功能描述 是否必填 host string 来自服务注册中心的服务名称。服务名称从平台的服务注册表（例如 Kubernetes 服务、Consul 服务等）和 ServiceEntries 声明的host中查找，找不到时则忽略该规则。host字段适用于HTTP和TCP服务。 是 trafficPolicy TrafficPolicy 要应用的流量策略（负载均衡策略、连接池大小、异常值检测） 否 subsets Subset[] 代表服务的各个版本的一个或多个命名集。也可以在子集级别设置流量策略。 否 exportTo string[] 将此DesinationRule导出到的namespace列表。应用到服务的DesinationRule的解析发生在namespace层次结构的上下文中。导出DesinationRule允许将其包含在其他namespace中服务的解析层次结构中。此功能为服务所有者和网格管理员提供了一种机制，以控制跨namespace边界的DesinationRule的可见性。如果未指定namespace，则默认情况下将DesinationRule导出到所有namespace。其中，.导出到声明DesinationRule的所在namespace，导出到所有namespace，在当前版本中，exportTo 值被限制为“.”。或“”。 否 Subset 服务端点的子集。 子集可用于 A/B 测试等场景，或路由到服务的特定版本。 此外，可以在子集级别覆盖在服务级别定义的流量策略。 以下规则对所有流向名为 testversion 的子集的流量使用循环负载均衡策略，该子集由带有标签 (version:v3) 的端点（例如 pod）组成。 apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: bookinfo-ratings spec: host: ratings.prod.svc.cluster.local trafficPolicy: loadBalancer: simple: LEAST_CONN subsets: - name: testversion labels: version: v3 trafficPolicy: loadBalancer: simple: ROUND_ROBIN 注意：在路由规则明确将流量发送到该子集之前，为子集指定的策略不会生效。 通常需要一个或多个标签来标识子集目的地，但是，当相应的 DestinationRule 表示支持多个 SNI 主机的主机（例如，出口网关）时， 没有标签的子集可能是有意义的。在这种情况下，可以使用带有 TLSSettings 的流量策略来识别与命名子集对应的特定 SNI 主机。 字段 类型 字段功能描述 是否必填 name string 子集的名称，服务名称和子集名称可用于路由规则中的流量拆分。 是 labels map 标签在服务注册表中的服务端点上应用过滤器，即对 Pod 属性进行的过滤。 否 trafficPolicy TrafficPolicy 适用于该子集的流量策略。子集继承在 DestinationRule 级别指定的流量策略。在子集级别指定的设置将覆盖在 DestinationRule 级别指定的相应设置。 否 TrafficPolicy By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap07/general.html":{"url":"chap07/general.html","title":"常见问题","keywords":"","body":" By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chap07/tips.html":{"url":"chap07/tips.html","title":"Tips","keywords":"","body":"Tips 修改sidecar镜像地址 在完成了 Istio 环境搭建后，我们可以设置某些 namespace 中可以自动注入 sidecar 容器。 其中，sidecar 镜像的默认镜像地址是: istio/proxyv2:1.8.3 很多时候，我们会在内网中搭建 k8s 集群，其实希望使用私域搭建的镜像仓库，这时可以通过修改 configmap 来设置 sidecar 镜像的仓库地址。 具体来说，设置方式如下： kubectl edit configmap istio-sidecar-injector -n istio-system 从 configmap 中找出 hub 的配置，并修改为自己的镜像仓库地址即可。 By wangzhe0912，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-07-17 09:03:42 new Valine({el: \"#vcomments\",appId: 'tE5W1eagY05N4M7ScOhP2gJM-gzGzoHsz',appKey: '1MzIFXCWSBYoIsM7JKg4X6So',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "}}